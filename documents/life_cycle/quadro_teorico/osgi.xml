<Implementações>

Segundo Bartlett (2009), a OSGi Alliance apenas define uma especificação do framework, por isso existem várias implementações do framework nos dias atuais, mas as quatro a seguir merecem destaque por serem as principais e por terem seu código livre.

Equinox é o framework mais usado atualmente, sua grande popularidade provém de fazer parte do gerenciador de plugins do Eclipse. Pode ser encontrado em muitos outros softwares, como os da IBM Lotus Notes
e WebSphere Application Server. Encontra-se sob a licença EPL (Eclipse Public
License) e implementa a versão 4.1 das especificações OSGi.

Knopflerfish é uma implementação bem madura e popular da versão 4.1 da especificação. É  desenvolvido e mantido pela empresa sueca Makewave AB, a qual oferece seu produto tanto em uma versão gratuita sob a licença BSD quanto uma versão comercial com suporte oferecido pela empresa.

Felix é a implementação mantida pela Apache Software Foundation, se encontra na versão 4.1 e possui foco na compactação e facilidade de incorporação do bundle na aplicação. Está sob a licença Apache 2.0.

Concierge é uma implementação bem compacta e altamente otimizada da especificação versão 3. É mais usado para plataformas com recursos limitados, como por exemplo aplicações móveis e embarcadas. Se encontra sob a licença BSD.
<referencia>
	BARTLETT, Neil. OSGi In Practice. 2009.
</referencia>
</Implementações>
<ciclo_de_vida_bundle>
	Bartlett (2009) afirma que um bundle pode passar por vários estados em seu ciclo de vida. A seguir é explicado cada uma desses estados e suas funções
	Installed - O bundle é instalado com êxito;
	Resolved - Avalia se o bundle está pronto para ser iniciado ou parado, validando informações como bundles,pacotes e versões destes, tais como até a versão do java necessária para executar o bundle;
	Starting - Estado de transição, em que nenhum bundle vai se encontrar nele, apenas é executado o ativador e logo em seguida, o bundle é passado para o estado descrito a seguir;
	Active - Nesse estado o bundle está validado e ativo, somente esperando alguma requisição para ser utilizado;
	Stopping - Parecido com o estado Starting, porém nele é executado o interruptor do bundle e este é transferido para o estado Resolved novamente;
	Uninstalled - Quando se ocorre a desinstalação do bundle, não se pode transitá-lo para nenhum outro estado e este não é mais representado no framework. Se este for reinstalado, ele assume o papel de um novo bundle.
	<imagem>estados_bundle_dentro_container_OSGi</imagem>
	Quando um bundle é instalado, ele fica armazenado em um meio persistente do framework e continua lá até ser explicitamente desinstalado(Fernandes, 2010).
	<referencia>
		BARTLETT, Neil. OSGi In Practice. 2009.
		FERNANDES, Leonardo. OSGi e os benefícios de uma Arquitetura Modular. 37.ed. 2009. p. 27-35.
	</referencia>
</ciclo_de_vida_bundle>

<framework>
	A diferença entre um bundle e um arquivo JAR tradicional são metadados adicionados no arquivo METAINF/
manifest.mf. Então, pode se usar um bundle JAR fora de um
contêiner OSGi.
A especificação define cerca de 20 metadados. Dentre eles. pode-se citar:
 - nome do bundle. É usado pelo contêiner para determinar uma identidade única.
 - versão do bundle.
 - Lista de imports e exports. Que informa ao framework quais classes o bundle precisa e quais interfaces o bundle deixa externamente
visíveis a outros módulos.
 - Activator. Um tipo de classe "main" que é chamada quando o
bundle é iniciado ou finalizado.
 - Informações como Contato, Copyright,etc.
Uma vantagem deste tipo de abordagem no processo de
desenvolvimento é uma
aproximação ao modelo incremental, pois no caso de alteração
num determinado bundle, tanto o build como o deploy, podem ser feitos
isoladamente do resto da aplicação.

<aqui></aqui>
Com relação a uma parte da sua arquitetura, o framework é conceitualmente
dividido nas seguintes camadas: (ver figura 1 para a visão geral
das camadas)
􀁴􀀁 􀀮􀁐􀁅􀁖􀁍􀁆􀀁􀀭􀁂􀁚􀁆􀁓􀀁􀁯􀀁Define o conceito de módulo do OSGi, como um
bundle pode importar e exportar código. Também provê a base
para funcionalidade do classload.
􀁴􀀁 􀀭􀁊􀁇􀁆􀁄􀁚􀁄􀁍􀁆􀀁􀀭􀁂􀁚􀁆􀁓􀀁􀁯􀀁Define como os bundles são dinamicamente instalados
e gerenciados no framework. Mais adiante será explicado
melhor como funciona o ciclo de vida de um bundle.
􀁴􀀁 􀀴􀁆􀁓􀁗􀁊􀁄􀁆􀀁􀀭􀁂􀁚􀁆􀁓􀀁􀁯􀀁Promove um modelo de desenvolvimento flexível
que incorpora o conceito de SOA (Service-Oriented Architecture),
publish-find-bind. Responsável por conectar os bundles de maneira
dinâmica.
<imagem></imagem>
</framework>