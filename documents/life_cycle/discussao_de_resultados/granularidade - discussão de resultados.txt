Umas das vantagens da modularização é a reutilização das funcionalidades que uma vez implementadas, podem ser reutilizadas em outros sistemas ou partes internas do mesmo sistema e, para se conseguir fazer isso foi necessário definir bem a estrutura do sistema, organizando as funcionalidades e responsabilidades de cada módulo, de forma em que sua arquitetura permitisse uma alta reutilização de funcionalidades. Porém essa organização da arquitetura exige que nos momentos iniciais do desenvolvimento do software seja criado uma granularidade adequada para o mesmo.
A granularidade é formada pelo tamanho ou complexidade dos módulos, quanto menor a granularidade do software, menores são os módulos, assim possuem menos inteligência de negócio dentro deles, isso facilita a reutilização dos módulos, porém dificulta o uso deles, pois o sistema ao todo terá um grande número de módulos, cada um representando uma funcionalidade, o que no caso, talvez se torne mais complicado e difícil de usar e expandir o sistema do que reutilizar. Mas em contra-partida temos a alta granularidade, onde um módulo possui uma granularidade maior, sendo relativamente grande e com mais inteligência de negócio, usar ele vai ser fácil, pois para executar uma rotina é necessário realizar a chamada a um serviço de determinado módulo, porém no momento em que alguma rotina ou código que está presente dentro daquele módulo tiver de ser reutilizada em outro local da aplicação, não vai ser possível, pois essa funcionalidade vai estar encapsulada junto ás outras dentro do módulo, impedindo assim de reutilizar ela (KNOERNSCHILD, 2012).
Com base na na teoria citada pelo autor Knoernschild, foram desenvolvidos vários protótipos até que encontramos a granularidade ideal para podermos desenvolver um software que exemplifica o modelo de desenvolvimento modular. Conforme mostra a figura 6, essa foi a granularidade criada para o software. É extremamente importante salientar que cada projeto, cada software vai possuir uma granularidade própia, ou seja, dependendo de cada software, de seu objetivo a ser atingido, essa granularidade vai estar se ajustando ao projeto. Com isso essa granularidade por nós autores encontrada pode ser profundamente alterada dependendo do projeto a ser desenvolvido utilizando OSGi.
_figura_
Nessa granularidade dividiu-se cada um dos módulos em outros menores, em que cada módulo principal teria três outros módulos menores dentro deles:
- a parte das interfaces dos serviços disponibilizadas aos outros módulos, ou seja , um módulo que contém a API;
- a parte da implementação dessas interfaces, nessa parte se teria as classes e códigos desenvolvidos em Java que implementariam as interfaces e teriam consigo a inteligência e regras de negócio da aplicação, essa parte é o módulo Core da aplicação;
- a parte da visualização e interação com o usuário, ou o front-end da aplicação, nessa parte estaria toda o código web que realizaria a interação com usuário,e comunicaria essas requisições com o servidor, enviando essas solicitações para o servidor, onde o OSGi verificaria qual o serviço que lhe devolveria a resposta da solicitação.
Houve alguns módulos que não apresentaram essa estrutura, como o módulo de Log e de banco de dados, esse módulos não possuem a parte de interação com o usuário, eles apenas servem como funcionalidades utilizadas pelos outros módulos, não necessitando assim de um módulo interno de visualização ou front-end.
Com a criação da granularidade do software, obtivemos várias vantagens, como alta possibilidade de reutilizar alguma funcionalidade desenvolvida em outra parte desse projeto desenvolvido na pesquisa ou até em outro software, já que com excessão do servidor online da Digital Ocean, todas as outras tecnologias utilizadas eram livres ou sem custo de uso. Além disso, com essa divisão entre as funcionalidades e códigos do sistema, conseguimos obter uma alta coesão e desacoplamento, uma vez que com essa granularidade cada módulo executa apenas a sua funcionalidade e não depende apenas de uma implementação, pois o framework OSGi permite utilização de múltiplas versões de uma mesma implementação.
Com base nas funcionalidades dos módulos do sistema, caso dividissê-mos uma funcionalidade para cada módulo, iríamos obter uma alta granularidade, assim o reaproveitamento de alguma funcionalidade presente dentro do módulo de financeiro por exemplo iria estar encapsulada, pois para reaproveitar em outra parte do sistema seria necessário levar junto todo o restante de códigos e funcionalidades do módulo, o que não é aceitável, pois teríamos no sistema código duplicado e que afetaria a coesão da implementação.
**********************************************
Com isso em mente, foram desenvolvidos vários protótipos até que encontramos a granularidade ideal para podermos desenvolver um software que exemplifica o modelo de desenvolvimento modular. Esse software possui as funcionalidades ou módulos macros: 
-Usuário, em que é feito o controle de login do usuário,e controle dessa conta dele, permitindo poder alterar senha ou nome do usuário;
-Financeiro, é feito um controle financeiro básico, onde se pode lançar contas a pagar, a receber e verificar relatórios a partir desses lançamentos;
-Clientes, é feito o cadastro e gerenciamento de clientes, os quais podem ser apontados no módulo financeiro;
**********************************************

Com base na teoria citada pelo autor.... Conforme mostra a figura 6, essa foi a granularidade criada para o software... lembrar u essa granularidade é apenas para esse exemplo, outros projetos terão que encontrar a sua granularidade.



****** figura ******


-----------------------------------------------------
QT
A granularidade de um software é definida a partir de como o sistema é dividido em
partes. Sendo assim partes maiores tendem a fazer mais operações do que partes menores.
Isso influencia diretamente no uso e reúso de código, como demonstra a Figura 1 a seguir.
Conforme mostra a Figura 1, quanto maior a granularidade dos módulos do sistema,
torna-se mais fácil usá-los e mais difícil de reutilizá-los. Do contrário, quanto menor a
granularidade, torna-se mais fácil reutilizá-los, e mais difícil usá-los (KNOERNSCHILD,
2012).