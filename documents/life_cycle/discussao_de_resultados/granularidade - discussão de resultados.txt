Felipe, se estiver lendo isso, tenha em mente que isso é apenas um rascunho do que irei fazer, não desespere se estiver viajando, pois só subi isso para poder salvar, mas aceito sugestões se estou falando certo ou se tem algo errado

Umas das vantagens da modularização é a reutilização de código/funcionalidades e, para se atingí-la foi necessário definir bem a estrutura do sistema, organizando as funcionalidades e responsabilidades de cada módulo, de forma em que sua arquitetura permitisse uma alta reutilização de funcionalidades. porém essa organização da arquitetura requeriu que nos momentos iniciais da pesquisa se achasse a granularidade adequada para o software, a granularidade é a medida do tamnho ou complexidade do módulo, quanto mais granularidade ele possui, menores são os módulos, possuem menos inteligência da aplicação dentro deles, isso facilita a reutilização dos módulos, porém dificulta o uso dele, pois o sistema ao todo terá um grande número de módulos, cada um representando um a funcionalidade, o que no caso, talvez se torne mais complicado e difícil usar e expandir o sistema do que reutilizar. Mas em contra-partida temos a baixa granularidade, onde um módulo é relativamente grande e com mais inteligência de negócio, usar ele vai ser fácil, pois para executar uma rotina é necessário realizar apenas um serviço de determinado módulo, porém no momento em que alguma rotina ou código que está presente dentro daquele módulo tiver de ser reutilizado em outro local da aplicação, não vai ser possível, pois essa funcionalidade vai estar junto ás outras dentro do módulo, impedindo assim de reutilizar apenas ela.
Com isso em mente, foram desenvolvidos vários protótipos até que encontramos a granularidade ideal para podermos desenvolver um software que exemplifica o modelo de desenvolvimento modular. Esse software possui as funcionalidades ou módulos macros: 
-Usuário, em que é feito o controle de login do usuário,e controle dessa conta dele, permitindo poder alterar senha ou nome do usuário;
-Financeiro, é feito um controle financeiro básico, onde se pode lançar contas a pagar, a receber e verificar relatórios a partir desses lançamentos;
-Clientes, é feito o cadastro e gerenciamento de clientes, os quais podem ser apontados no módulo financeiro;
Com base nessas funcionalidades macros, caso dividissê-mos uma funcionalidade para cada módulo, iríamos obter uma baixa granularidade, assim o reaproveitamento de alguma funcionalidade presente dentro do módulo de financeiro por exemplo iria estar bloqueada, pois para reaproveitar em outra parte do sistema seria necessário levar junto todo o restante de códigos e funcionalidades do módulo, o que não é aceitável, pois teria código duplicado e sem uso.
Nesse caso dividiu-se cada um desses módulos macros em outros menores, em que teria três partes:
- a parte das interfaces dos serviços disponibilizadas aos outros módulos, ou seja , a API do módulo;
- a parte da implementação dessas interfaces, nessa parte se teria as classes e códigos desenvolvidos em Java que implementariam as interfaces e teriam consigo a inteligência e regras de negócio da aplicação, essa parte denominou-se Core da aplicação;
- a parte da visualização e interação com o usuário, ou o front-end da aplicação, nessa parte estaria toda o código web que realizaria a interação com usuário,e comunicaria essas requisições com o servidor, enviando essas solicitações para o servidor, onde o OSGi verificaria qual o serviço que lhe devolveria a resposta da solicitação.
Houve alguns módulos que não apresentaram essa estrutura, como o módulo de Log e de banco de dados, esse módulos não possuem a parte de interação com o usuário, eles apenas servem como funcionalidades utilizadas pelos outros módulos, não necessitando assim de um módulo interno de visualização ou front-end.
Com essas divisões para os módulos, obtivemos várias vantagens, como descreveremos a seguir:
- reutilização(utilizar)
- poder parar,atualizar e adicionar módulos com o sistema ainda em funcionamento
- coesão do software
- facilidade de teste do software
- facilidade de codificação, pois pode-se ter várias equipes em desenvolvimento paralelo, cada uma implementando um módulo/funcionalidade diferente